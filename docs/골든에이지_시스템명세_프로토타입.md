# GoldenAge 프로토타입 - 시스템 명세서

> **문서 버전**: 1.1
> **작성일**: 2026년 1월
> **대상 독자**: 초보 게임 개발자 (1인 개발)
> **연관 문서**: TDD_프로토타입.md

---

## 문서 개요

본 문서는 프로토타입에서 구현할 6개 시스템의 상세 명세를 정의합니다.

| 시스템 | 우선순위 | 구현 복잡도 | 예상 개발 기간 |
|--------|---------|-----------|--------------|
| 이동 시스템 | 최상 | 낮음 | 1주 |
| 전투 시스템 | 최상 | 높음 | 4주 |
| 대화 시스템 | 높음 | 중간 | 2주 |
| 인벤토리 시스템 | 중간 | 낮음 | 1주 |
| 퀘스트 시스템 | 중간 | 중간 | 2주 |
| 저장/불러오기 | 낮음 | 낮음 | 1주 |

---

## 1. 이동 시스템

### 1.1 개요

플레이어 캐릭터의 3인칭 이동을 담당하는 시스템입니다.

```
[이동 시스템 구조]

Input System ──► PlayerMovement ──► CharacterController
                      │
                      ├── 걷기/달리기
                      ├── 점프 (선택)
                      └── 회전
```

### 1.2 이동 파라미터

| 파라미터 | 값 | 설명 |
|---------|-----|------|
| 걷기 속도 | 4 m/s | 기본 이동 속도 |
| 달리기 속도 | 7 m/s | Shift 홀드 시 |
| 회전 속도 | 10 deg/s | 카메라 방향 기준 회전 |
| 중력 | -9.81 m/s² | 기본 물리 중력 |
| 점프 높이 | 1.5m | (선택적 구현) |

### 1.3 PlayerMovement 클래스

```csharp
using UnityEngine;
using UnityEngine.InputSystem;

[RequireComponent(typeof(CharacterController))]
public class PlayerMovement : MonoBehaviour
{
    [Header("이동 설정")]
    [SerializeField] private float walkSpeed = 4f;
    [SerializeField] private float runSpeed = 7f;
    [SerializeField] private float rotationSmoothTime = 0.1f;
    [SerializeField] private float gravity = -9.81f;

    [Header("참조")]
    [SerializeField] private Transform cameraTransform;

    private CharacterController controller;
    private PlayerInputActions inputActions;

    private Vector2 moveInput;
    private bool isRunning;
    private float currentSpeed;
    private float rotationVelocity;
    private Vector3 verticalVelocity;

    private void Awake()
    {
        controller = GetComponent<CharacterController>();
        inputActions = new PlayerInputActions();
    }

    private void OnEnable()
    {
        inputActions.Player.Enable();
        inputActions.Player.Move.performed += OnMovePerformed;
        inputActions.Player.Move.canceled += OnMoveCanceled;
        inputActions.Player.Sprint.performed += _ => isRunning = true;
        inputActions.Player.Sprint.canceled += _ => isRunning = false;
    }

    private void OnDisable()
    {
        inputActions.Player.Disable();
    }

    private void OnMovePerformed(InputAction.CallbackContext ctx)
    {
        moveInput = ctx.ReadValue<Vector2>();
    }

    private void OnMoveCanceled(InputAction.CallbackContext ctx)
    {
        moveInput = Vector2.zero;
    }

    private void Update()
    {
        // 게임 상태 체크
        if (GameManager.Instance.CurrentState == GameState.Dialogue ||
            GameManager.Instance.CurrentState == GameState.Paused)
        {
            return;
        }

        HandleMovement();
        ApplyGravity();
    }

    private void HandleMovement()
    {
        if (moveInput.sqrMagnitude < 0.01f)
        {
            // 애니메이션: Idle 상태로 전환
            return;
        }

        // 카메라 기준 이동 방향 계산
        Vector3 inputDirection = new Vector3(moveInput.x, 0, moveInput.y).normalized;

        float targetAngle = Mathf.Atan2(inputDirection.x, inputDirection.z) * Mathf.Rad2Deg
                            + cameraTransform.eulerAngles.y;

        // 부드러운 회전
        float angle = Mathf.SmoothDampAngle(
            transform.eulerAngles.y,
            targetAngle,
            ref rotationVelocity,
            rotationSmoothTime
        );
        transform.rotation = Quaternion.Euler(0, angle, 0);

        // 이동
        currentSpeed = isRunning ? runSpeed : walkSpeed;
        Vector3 moveDirection = Quaternion.Euler(0, targetAngle, 0) * Vector3.forward;
        controller.Move(moveDirection * currentSpeed * Time.deltaTime);
    }

    private void ApplyGravity()
    {
        if (controller.isGrounded && verticalVelocity.y < 0)
        {
            verticalVelocity.y = -2f; // 약간의 하향 힘으로 바닥 밀착
        }

        verticalVelocity.y += gravity * Time.deltaTime;
        controller.Move(verticalVelocity * Time.deltaTime);
    }

    // 외부에서 속도 정보 접근
    public float GetCurrentSpeed() => currentSpeed;
    public bool IsMoving() => moveInput.sqrMagnitude > 0.01f;
    public bool IsRunning() => isRunning && IsMoving();
}
```

### 1.4 상호작용 시스템

```csharp
public class InteractionSystem : MonoBehaviour
{
    [Header("설정")]
    [SerializeField] private float interactionRange = 2f;
    [SerializeField] private LayerMask interactableLayer;
    [SerializeField] private Transform interactionPoint; // 플레이어 앞쪽

    private PlayerInputActions inputActions;
    private IInteractable currentTarget;

    private void Update()
    {
        DetectInteractable();
    }

    private void DetectInteractable()
    {
        Collider[] hits = Physics.OverlapSphere(
            interactionPoint.position,
            interactionRange,
            interactableLayer
        );

        if (hits.Length > 0)
        {
            // 가장 가까운 상호작용 대상 선택
            IInteractable nearest = hits[0].GetComponent<IInteractable>();
            if (nearest != currentTarget)
            {
                currentTarget?.OnDeselect();
                currentTarget = nearest;
                currentTarget?.OnSelect();
            }
        }
        else
        {
            currentTarget?.OnDeselect();
            currentTarget = null;
        }
    }

    private void OnInteract(InputAction.CallbackContext ctx)
    {
        if (ctx.performed && currentTarget != null)
        {
            currentTarget.Interact();
        }
    }
}

// 상호작용 가능 인터페이스
public interface IInteractable
{
    void OnSelect();      // 범위 내 진입 시
    void OnDeselect();    // 범위 이탈 시
    void Interact();      // E키 입력 시
    string GetInteractionPrompt(); // UI 표시용 ("E: 대화하기")
}
```

### 1.5 이동 애니메이션 연동

```csharp
public class PlayerAnimator : MonoBehaviour
{
    private Animator animator;
    private PlayerMovement movement;

    // 애니메이터 파라미터 해시
    private static readonly int SpeedHash = Animator.StringToHash("Speed");
    private static readonly int IsGroundedHash = Animator.StringToHash("IsGrounded");

    private void Awake()
    {
        animator = GetComponent<Animator>();
        movement = GetComponent<PlayerMovement>();
    }

    private void Update()
    {
        // 속도에 따른 블렌드
        float normalizedSpeed = movement.IsRunning() ? 1f :
                               movement.IsMoving() ? 0.5f : 0f;
        animator.SetFloat(SpeedHash, normalizedSpeed, 0.1f, Time.deltaTime);
    }
}
```

**Animator Controller 구조:**
```
[Locomotion Layer]

Entry ──► Idle
             │
             ▼ (Speed > 0.1)
          Walk
             │
             ▼ (Speed > 0.7)
           Run
```

---

## 2. 전투 시스템

### 2.1 개요

프로토타입의 핵심 시스템으로, 과학-마법 융합 전투를 구현합니다.

```
[전투 시스템 구조]

┌─────────────────────────────────────────────────────────────┐
│                       CombatManager                          │
│  - 전투 상태 관리                                             │
│  - 데미지 계산                                                │
│  - 적 스폰/관리                                               │
└──────────────────────┬──────────────────────────────────────┘
                       │
        ┌──────────────┼──────────────┐
        ▼              ▼              ▼
┌──────────────┐ ┌──────────────┐ ┌──────────────┐
│ PlayerCombat │ │  EnemyAI     │ │ DamageSystem │
│ - 입력 처리   │ │ - 행동 패턴  │ │ - 피격 판정  │
│ - 스킬 실행   │ │ - 타겟팅    │ │ - 효과 적용  │
└──────────────┘ └──────────────┘ └──────────────┘
```

### 2.2 공격 종류

#### 프로토타입 구현 범위

| 공격 유형 | 카테고리 | 데미지 | 쿨타임 | 범위 |
|----------|--------|-------|-------|------|
| 근접 공격 | 기본 | 15 | 0.8초 | 2m |
| 권총 사격 | 기본 | 20 | 0.5초 | 30m |
| 테슬라 충격기 | 과학 | 35 | 8초 | 5m (원형) |
| 에테르 파동 | 마법 | 30 | 6초 | 10m (직선) |
| **융합 콤보** | 특수 | 80 | 15초 | 8m (원형) |

#### 융합 콤보 조건
```
[테슬라 충격기 히트] + [에테르 파동 히트] (3초 이내)
    │
    ▼
[차원 전격 발동] - 증폭된 범위 피해 + 스턴 효과
```

### 2.3 데이터 구조

```csharp
// 공격 데이터
[CreateAssetMenu(fileName = "NewAttack", menuName = "GoldenAge/Attack Data")]
public class AttackData : ScriptableObject
{
    [Header("기본 정보")]
    public string attackName;
    public AttackType attackType;
    public DamageType damageType;

    [Header("스탯")]
    public int baseDamage = 10;
    public float range = 2f;
    public float cooldown = 1f;
    public float castTime = 0f;        // 시전 시간
    public float animationDuration = 0.5f;

    [Header("범위 공격")]
    public bool isAOE = false;
    public float aoeRadius = 0f;
    public AOEShape aoeShape;

    [Header("효과")]
    public StatusEffect[] applyEffects;
    public GameObject hitVFX;
    public AudioClip hitSFX;
}

public enum AttackType
{
    Melee,      // 근접
    Ranged,     // 원거리
    Science,    // 과학
    Magic,      // 마법
    Fusion      // 융합
}

public enum DamageType
{
    Physical,
    Electric,
    Dimensional,
    Fusion
}

public enum AOEShape
{
    Circle,
    Cone,
    Line
}
```

```csharp
// 상태이상 효과
[CreateAssetMenu(fileName = "NewEffect", menuName = "GoldenAge/Status Effect")]
public class StatusEffect : ScriptableObject
{
    public string effectName;
    public EffectType effectType;
    public float duration = 3f;
    public float tickInterval = 1f;     // 도트 데미지 간격

    [Header("수치")]
    public int damagePerTick = 0;       // 도트 데미지
    public float slowPercent = 0f;      // 이동속도 감소 (0~1)
    public bool isStunned = false;      // 스턴 여부

    public GameObject effectVFX;
}

public enum EffectType
{
    None,
    Stun,           // 행동 불가
    Slow,           // 이동속도 감소
    Electrified,    // 전기 감전 (도트)
    DimensionMark   // 차원 표식 (융합 콤보용)
}
```

### 2.4 PlayerCombat 클래스

```csharp
public class PlayerCombat : MonoBehaviour
{
    [Header("공격 데이터")]
    [SerializeField] private AttackData meleeAttack;
    [SerializeField] private AttackData rangedAttack;
    [SerializeField] private AttackData teslaShock;      // 테슬라 충격기
    [SerializeField] private AttackData etherWave;       // 에테르 파동
    [SerializeField] private AttackData fusionBlast;     // 융합 콤보

    [Header("참조")]
    [SerializeField] private Transform attackPoint;
    [SerializeField] private LayerMask enemyLayer;

    private PlayerInputActions inputActions;
    private Dictionary<AttackData, float> cooldownTimers = new();
    private bool canAttack = true;

    // 융합 콤보 추적
    private bool teslaHitRecently = false;
    private bool etherHitRecently = false;
    private float fusionWindowTimer = 0f;
    private const float FUSION_WINDOW = 3f;

    private void Awake()
    {
        inputActions = new PlayerInputActions();
        InitializeCooldowns();
    }

    private void OnEnable()
    {
        inputActions.Player.Enable();
        inputActions.Player.Attack.performed += OnAttack;
        inputActions.Player.Skill1.performed += OnTeslaShock;
        inputActions.Player.Skill2.performed += OnEtherWave;
    }

    private void Update()
    {
        UpdateCooldowns();
        UpdateFusionWindow();
    }

    private void InitializeCooldowns()
    {
        cooldownTimers[meleeAttack] = 0f;
        cooldownTimers[rangedAttack] = 0f;
        cooldownTimers[teslaShock] = 0f;
        cooldownTimers[etherWave] = 0f;
        cooldownTimers[fusionBlast] = 0f;
    }

    private void UpdateCooldowns()
    {
        var keys = new List<AttackData>(cooldownTimers.Keys);
        foreach (var key in keys)
        {
            if (cooldownTimers[key] > 0)
                cooldownTimers[key] -= Time.deltaTime;
        }
    }

    private void UpdateFusionWindow()
    {
        if (teslaHitRecently || etherHitRecently)
        {
            fusionWindowTimer -= Time.deltaTime;
            if (fusionWindowTimer <= 0)
            {
                teslaHitRecently = false;
                etherHitRecently = false;
            }
        }
    }

    // ===== 기본 공격 =====
    private void OnAttack(InputAction.CallbackContext ctx)
    {
        if (!canAttack) return;

        // 근접/원거리 토글 또는 상황에 따라 선택
        AttackData attack = meleeAttack; // 기본은 근접

        if (IsOnCooldown(attack)) return;

        StartCoroutine(ExecuteAttack(attack));
    }

    // ===== 테슬라 충격기 (Q) =====
    private void OnTeslaShock(InputAction.CallbackContext ctx)
    {
        if (!canAttack || IsOnCooldown(teslaShock)) return;
        StartCoroutine(ExecuteAttack(teslaShock));
    }

    // ===== 에테르 파동 (R) =====
    private void OnEtherWave(InputAction.CallbackContext ctx)
    {
        if (!canAttack || IsOnCooldown(etherWave)) return;
        StartCoroutine(ExecuteAttack(etherWave));
    }

    private IEnumerator ExecuteAttack(AttackData attack)
    {
        canAttack = false;
        cooldownTimers[attack] = attack.cooldown;

        // 시전 시간
        if (attack.castTime > 0)
            yield return new WaitForSeconds(attack.castTime);

        // 애니메이션 트리거
        // animator.SetTrigger(attack.attackName);

        // 판정 실행
        List<IDamageable> hitTargets = PerformHitDetection(attack);

        // 데미지 적용
        foreach (var target in hitTargets)
        {
            int finalDamage = CalculateDamage(attack);
            target.TakeDamage(finalDamage, attack.damageType);

            // 상태이상 적용
            foreach (var effect in attack.applyEffects)
            {
                target.ApplyEffect(effect);
            }

            // 융합 콤보 체크
            CheckFusionCombo(attack, target);
        }

        // 이펙트/사운드
        SpawnHitEffects(attack, hitTargets);

        yield return new WaitForSeconds(attack.animationDuration);
        canAttack = true;
    }

    private List<IDamageable> PerformHitDetection(AttackData attack)
    {
        List<IDamageable> targets = new();

        if (attack.isAOE)
        {
            // AOE 판정
            Collider[] hits = Physics.OverlapSphere(
                attackPoint.position,
                attack.aoeRadius,
                enemyLayer
            );

            foreach (var hit in hits)
            {
                if (hit.TryGetComponent<IDamageable>(out var damageable))
                    targets.Add(damageable);
            }
        }
        else
        {
            // 단일 대상 판정
            if (Physics.Raycast(
                attackPoint.position,
                transform.forward,
                out RaycastHit hit,
                attack.range,
                enemyLayer))
            {
                if (hit.collider.TryGetComponent<IDamageable>(out var damageable))
                    targets.Add(damageable);
            }
        }

        return targets;
    }

    private int CalculateDamage(AttackData attack)
    {
        // 기본 공식: 기본 데미지 * (1 + 보너스)
        // 프로토타입에서는 단순화
        return attack.baseDamage;
    }

    private void CheckFusionCombo(AttackData attack, IDamageable target)
    {
        if (attack == teslaShock)
        {
            teslaHitRecently = true;
            fusionWindowTimer = FUSION_WINDOW;
        }
        else if (attack == etherWave)
        {
            etherHitRecently = true;
            fusionWindowTimer = FUSION_WINDOW;
        }

        // 융합 조건 충족 시 자동 발동
        if (teslaHitRecently && etherHitRecently && !IsOnCooldown(fusionBlast))
        {
            StartCoroutine(ExecuteFusionBlast());
        }
    }

    private IEnumerator ExecuteFusionBlast()
    {
        teslaHitRecently = false;
        etherHitRecently = false;
        cooldownTimers[fusionBlast] = fusionBlast.cooldown;

        // 융합 공격 연출
        Debug.Log("차원 전격 발동!");

        // 범위 내 모든 적에게 피해
        Collider[] hits = Physics.OverlapSphere(
            transform.position,
            fusionBlast.aoeRadius,
            enemyLayer
        );

        foreach (var hit in hits)
        {
            if (hit.TryGetComponent<IDamageable>(out var damageable))
            {
                damageable.TakeDamage(fusionBlast.baseDamage, DamageType.Fusion);

                // 스턴 효과 적용
                foreach (var effect in fusionBlast.applyEffects)
                {
                    damageable.ApplyEffect(effect);
                }
            }
        }

        yield return null;
    }

    private bool IsOnCooldown(AttackData attack)
    {
        return cooldownTimers.TryGetValue(attack, out float time) && time > 0;
    }

    public float GetCooldownPercent(AttackData attack)
    {
        if (cooldownTimers.TryGetValue(attack, out float remaining))
            return remaining / attack.cooldown;
        return 0f;
    }
}
```

### 2.5 적 AI (EnemyAI)

```csharp
public class EnemyAI : MonoBehaviour, IDamageable
{
    [Header("스탯")]
    [SerializeField] private CharacterData characterData;

    [Header("AI 설정")]
    [SerializeField] private float detectionRange = 10f;
    [SerializeField] private float attackRange = 2f;
    [SerializeField] private float patrolSpeed = 2f;
    [SerializeField] private float chaseSpeed = 4f;

    private int currentHealth;
    private Transform player;
    private NavMeshAgent agent;
    private EnemyState currentState = EnemyState.Idle;

    // 상태이상
    private List<ActiveEffect> activeEffects = new();
    private bool isStunned = false;

    private void Awake()
    {
        agent = GetComponent<NavMeshAgent>();
        currentHealth = characterData.maxHealth;
        player = GameObject.FindGameObjectWithTag("Player").transform;
    }

    private void Update()
    {
        UpdateEffects();

        if (isStunned) return;

        switch (currentState)
        {
            case EnemyState.Idle:
                CheckForPlayer();
                break;
            case EnemyState.Chase:
                ChasePlayer();
                break;
            case EnemyState.Attack:
                AttackPlayer();
                break;
        }
    }

    private void CheckForPlayer()
    {
        float distance = Vector3.Distance(transform.position, player.position);
        if (distance <= detectionRange)
        {
            currentState = EnemyState.Chase;
        }
    }

    private void ChasePlayer()
    {
        float distance = Vector3.Distance(transform.position, player.position);

        if (distance <= attackRange)
        {
            currentState = EnemyState.Attack;
            agent.isStopped = true;
        }
        else if (distance > detectionRange * 1.5f)
        {
            currentState = EnemyState.Idle;
            agent.isStopped = true;
        }
        else
        {
            agent.isStopped = false;
            agent.speed = chaseSpeed;
            agent.SetDestination(player.position);
        }
    }

    private void AttackPlayer()
    {
        float distance = Vector3.Distance(transform.position, player.position);

        if (distance > attackRange * 1.2f)
        {
            currentState = EnemyState.Chase;
            return;
        }

        // 공격 로직 (쿨다운 체크 필요)
        // ...
    }

    // ===== IDamageable 구현 =====
    public void TakeDamage(int damage, DamageType damageType)
    {
        // 방어력 적용
        int finalDamage = Mathf.Max(1, damage - characterData.defense);
        currentHealth -= finalDamage;

        // 피격 반응
        // animator.SetTrigger("Hit");

        if (currentHealth <= 0)
        {
            Die();
        }
    }

    public void ApplyEffect(StatusEffect effect)
    {
        ActiveEffect active = new ActiveEffect
        {
            effect = effect,
            remainingDuration = effect.duration,
            nextTickTime = Time.time + effect.tickInterval
        };
        activeEffects.Add(active);

        // 즉시 효과 적용
        if (effect.isStunned)
            isStunned = true;
        if (effect.slowPercent > 0)
            agent.speed *= (1f - effect.slowPercent);
    }

    private void UpdateEffects()
    {
        for (int i = activeEffects.Count - 1; i >= 0; i--)
        {
            var active = activeEffects[i];
            active.remainingDuration -= Time.deltaTime;

            // 도트 데미지
            if (active.effect.damagePerTick > 0 && Time.time >= active.nextTickTime)
            {
                currentHealth -= active.effect.damagePerTick;
                active.nextTickTime = Time.time + active.effect.tickInterval;
            }

            // 효과 종료
            if (active.remainingDuration <= 0)
            {
                RemoveEffect(active);
                activeEffects.RemoveAt(i);
            }
        }
    }

    private void RemoveEffect(ActiveEffect active)
    {
        if (active.effect.isStunned)
            isStunned = false;
        if (active.effect.slowPercent > 0)
            agent.speed = characterData.moveSpeed;
    }

    private void Die()
    {
        // 사망 처리
        // - 애니메이션
        // - 아이템 드롭
        // - 퀘스트 업데이트
        CombatManager.Instance.OnEnemyKilled(this);
        Destroy(gameObject, 2f);
    }
}

public enum EnemyState
{
    Idle,
    Patrol,
    Chase,
    Attack,
    Dead
}

[System.Serializable]
public class ActiveEffect
{
    public StatusEffect effect;
    public float remainingDuration;
    public float nextTickTime;
}
```

### 2.6 PlayerStats 클래스

```csharp
using UnityEngine;

public class PlayerStats : MonoBehaviour
{
    [Header("기본 스탯")]
    [SerializeField] private int maxHealth = 100;
    [SerializeField] private int maxEnergy = 100;

    [Header("레벨 시스템")]
    [SerializeField] private int level = 1;
    [SerializeField] private int experience = 0;
    [SerializeField] private int experienceToNextLevel = 100;
    [SerializeField] private float expMultiplier = 1.5f; // 레벨업 시 필요 경험치 증가율

    private int currentHealth;
    private int currentEnergy;

    public int CurrentHealth => currentHealth;
    public int MaxHealth => maxHealth;
    public int CurrentEnergy => currentEnergy;
    public int MaxEnergy => maxEnergy;
    public int Level => level;
    public int Experience => experience;
    public int ExperienceToNextLevel => experienceToNextLevel;

    public event System.Action<int, int> OnHealthChanged;      // current, max
    public event System.Action<int, int> OnEnergyChanged;      // current, max
    public event System.Action<int> OnLevelUp;                 // new level

    private void Awake()
    {
        currentHealth = maxHealth;
        currentEnergy = maxEnergy;
    }

    public void TakeDamage(int damage)
    {
        currentHealth = Mathf.Max(0, currentHealth - damage);
        OnHealthChanged?.Invoke(currentHealth, maxHealth);

        if (currentHealth <= 0)
        {
            Die();
        }
    }

    public void Heal(int amount)
    {
        currentHealth = Mathf.Min(maxHealth, currentHealth + amount);
        OnHealthChanged?.Invoke(currentHealth, maxHealth);
    }

    public void RestoreEnergy(int amount)
    {
        currentEnergy = Mathf.Min(maxEnergy, currentEnergy + amount);
        OnEnergyChanged?.Invoke(currentEnergy, maxEnergy);
    }

    public bool UseEnergy(int amount)
    {
        if (currentEnergy < amount) return false;

        currentEnergy -= amount;
        OnEnergyChanged?.Invoke(currentEnergy, maxEnergy);
        return true;
    }

    public void AddExperience(int exp)
    {
        experience += exp;

        while (experience >= experienceToNextLevel)
        {
            experience -= experienceToNextLevel;
            LevelUp();
        }
    }

    private void LevelUp()
    {
        level++;
        experienceToNextLevel = Mathf.RoundToInt(experienceToNextLevel * expMultiplier);

        // 레벨업 보너스
        maxHealth += 10;
        maxEnergy += 5;
        currentHealth = maxHealth;  // 체력 완전 회복
        currentEnergy = maxEnergy;  // 에너지 완전 회복

        OnLevelUp?.Invoke(level);
        Debug.Log($"레벨 업! 현재 레벨: {level}");
    }

    private void Die()
    {
        Debug.Log("플레이어 사망!");
        GameManager.Instance.ChangeState(GameState.Paused);
        // 게임 오버 UI 표시 등
    }

    // 저장/불러오기용 메서드
    public void SetHealth(int current, int max)
    {
        maxHealth = max;
        currentHealth = Mathf.Clamp(current, 0, max);
        OnHealthChanged?.Invoke(currentHealth, maxHealth);
    }

    public void SetLevel(int newLevel, int newExp)
    {
        level = newLevel;
        experience = newExp;
        // 레벨에 따른 스탯 재계산
        maxHealth = 100 + (level - 1) * 10;
        maxEnergy = 100 + (level - 1) * 5;
    }
}
```

### 2.7 CombatManager 클래스

```csharp
using UnityEngine;
using System.Collections.Generic;

public class CombatManager : Singleton<CombatManager>
{
    [Header("전투 설정")]
    [SerializeField] private float combatExitDelay = 5f; // 전투 종료 후 탐색 모드 전환 시간

    private bool isInCombat;
    private float lastCombatTime;
    private List<EnemyAI> activeEnemies = new List<EnemyAI>();

    public bool IsInCombat => isInCombat;
    public int ActiveEnemyCount => activeEnemies.Count;

    public event System.Action OnCombatStart;
    public event System.Action OnCombatEnd;
    public event System.Action<EnemyAI> OnEnemyKilledEvent;

    private void Update()
    {
        // 전투 종료 체크
        if (isInCombat && activeEnemies.Count == 0)
        {
            if (Time.time - lastCombatTime > combatExitDelay)
            {
                EndCombat();
            }
        }
    }

    public void EnterCombat()
    {
        if (isInCombat) return;

        isInCombat = true;
        lastCombatTime = Time.time;
        GameManager.Instance.ChangeState(GameState.Combat);
        OnCombatStart?.Invoke();

        // 전투 BGM 시작
        AudioManager.Instance.PlayBGM("Combat");
        Debug.Log("전투 시작!");
    }

    public void EndCombat()
    {
        if (!isInCombat) return;

        isInCombat = false;
        GameManager.Instance.ChangeState(GameState.Exploration);
        OnCombatEnd?.Invoke();

        // 탐색 BGM으로 전환
        AudioManager.Instance.PlayBGM("Exploration");
        Debug.Log("전투 종료!");
    }

    public void RegisterEnemy(EnemyAI enemy)
    {
        if (!activeEnemies.Contains(enemy))
        {
            activeEnemies.Add(enemy);
            EnterCombat();
        }
    }

    public void OnEnemyKilled(EnemyAI enemy)
    {
        activeEnemies.Remove(enemy);
        lastCombatTime = Time.time;

        OnEnemyKilledEvent?.Invoke(enemy);

        // 퀘스트 업데이트
        QuestManager.Instance.UpdateObjective(ObjectiveType.KillEnemy, enemy.EnemyID);

        // 경험치 지급
        PlayerStats playerStats = FindObjectOfType<PlayerStats>();
        playerStats?.AddExperience(enemy.ExpReward);

        Debug.Log($"적 처치: {enemy.EnemyID}, 남은 적: {activeEnemies.Count}");
    }

    // 데미지 계산 (공격자 스탯, 방어자 스탯, 공격 데이터 기반)
    public int CalculateDamage(int baseDamage, int attackerLevel, int defenderDefense)
    {
        // 기본 공식: 기본 데미지 * (1 + 레벨 보너스) - 방어력
        float levelBonus = 1f + (attackerLevel - 1) * 0.1f;
        int rawDamage = Mathf.RoundToInt(baseDamage * levelBonus);
        int finalDamage = Mathf.Max(1, rawDamage - defenderDefense);

        return finalDamage;
    }

    // 크리티컬 히트 판정
    public bool RollCritical(float critChance = 0.1f)
    {
        return Random.value < critChance;
    }

    // 데미지에 크리티컬 적용
    public int ApplyCritical(int damage, float critMultiplier = 1.5f)
    {
        return Mathf.RoundToInt(damage * critMultiplier);
    }
}
```

### 2.8 SpawnHitEffects 메서드 (PlayerCombat 확장)

```csharp
// PlayerCombat 클래스에 추가할 메서드
private void SpawnHitEffects(AttackData attack, List<IDamageable> hitTargets)
{
    foreach (var target in hitTargets)
    {
        // 타겟 위치 가져오기
        MonoBehaviour targetMono = target as MonoBehaviour;
        if (targetMono == null) continue;

        Vector3 hitPosition = targetMono.transform.position + Vector3.up; // 몸통 높이

        // VFX 스폰
        if (attack.hitVFX != null)
        {
            GameObject vfx = Instantiate(attack.hitVFX, hitPosition, Quaternion.identity);
            Destroy(vfx, 2f); // 2초 후 자동 파괴
        }

        // SFX 재생
        if (attack.hitSFX != null)
        {
            AudioSource.PlayClipAtPoint(attack.hitSFX, hitPosition);
        }

        // 데미지 텍스트 표시 (옵션)
        SpawnDamageText(hitPosition, attack.baseDamage);
    }
}

// 데미지 텍스트 스폰 (선택적 구현)
private void SpawnDamageText(Vector3 position, int damage)
{
    // UI 데미지 텍스트 프리팹이 있는 경우
    // DamageTextPool에서 가져와서 표시
    // 간단 버전: Debug.Log
    Debug.Log($"데미지: {damage}");
}
```

### 2.9 AudioManager 클래스 (음성 재생 포함)

```csharp
using UnityEngine;
using System.Collections.Generic;

public class AudioManager : Singleton<AudioManager>
{
    [Header("Audio Sources")]
    [SerializeField] private AudioSource bgmSource;
    [SerializeField] private AudioSource sfxSource;
    [SerializeField] private AudioSource voiceSource;

    [Header("Audio Clips")]
    [SerializeField] private List<BGMClip> bgmClips = new List<BGMClip>();
    [SerializeField] private List<SFXClip> sfxClips = new List<SFXClip>();

    [Header("Settings")]
    [SerializeField] private float bgmFadeDuration = 1f;

    private Dictionary<string, AudioClip> bgmDict = new Dictionary<string, AudioClip>();
    private Dictionary<string, AudioClip> sfxDict = new Dictionary<string, AudioClip>();

    protected override void Awake()
    {
        base.Awake();

        // 딕셔너리 초기화
        foreach (var clip in bgmClips)
            bgmDict[clip.name] = clip.clip;
        foreach (var clip in sfxClips)
            sfxDict[clip.name] = clip.clip;
    }

    public void PlayBGM(string name)
    {
        if (bgmDict.TryGetValue(name, out AudioClip clip))
        {
            if (bgmSource.clip == clip && bgmSource.isPlaying)
                return; // 이미 재생 중

            StartCoroutine(FadeBGM(clip));
        }
    }

    private System.Collections.IEnumerator FadeBGM(AudioClip newClip)
    {
        // 페이드 아웃
        float startVolume = bgmSource.volume;
        while (bgmSource.volume > 0)
        {
            bgmSource.volume -= startVolume * Time.deltaTime / (bgmFadeDuration / 2);
            yield return null;
        }

        // 클립 변경
        bgmSource.clip = newClip;
        bgmSource.Play();

        // 페이드 인
        while (bgmSource.volume < startVolume)
        {
            bgmSource.volume += startVolume * Time.deltaTime / (bgmFadeDuration / 2);
            yield return null;
        }
    }

    public void PlaySFX(string name)
    {
        if (sfxDict.TryGetValue(name, out AudioClip clip))
        {
            sfxSource.PlayOneShot(clip);
        }
    }

    public void PlaySFX(AudioClip clip)
    {
        if (clip != null)
        {
            sfxSource.PlayOneShot(clip);
        }
    }

    public void PlayVoice(AudioClip clip)
    {
        if (clip == null) return;

        // 기존 음성 중지 후 새 음성 재생
        voiceSource.Stop();
        voiceSource.clip = clip;
        voiceSource.Play();
    }

    public void StopVoice()
    {
        voiceSource.Stop();
    }

    public void StopAll()
    {
        bgmSource.Stop();
        sfxSource.Stop();
        voiceSource.Stop();
    }

    public void SetBGMVolume(float volume)
    {
        bgmSource.volume = Mathf.Clamp01(volume);
    }

    public void SetSFXVolume(float volume)
    {
        sfxSource.volume = Mathf.Clamp01(volume);
    }
}

[System.Serializable]
public class BGMClip
{
    public string name;
    public AudioClip clip;
}

[System.Serializable]
public class SFXClip
{
    public string name;
    public AudioClip clip;
}
```

### 2.10 인터페이스 정의

```csharp
public interface IDamageable
{
    void TakeDamage(int damage, DamageType damageType);
    void ApplyEffect(StatusEffect effect);
}

public interface IAttacker
{
    void Attack(IDamageable target);
}
```

### 2.11 밸런스 데이터 테이블

#### 플레이어 스탯 (레벨별)

| 레벨 | 최대 HP | 최대 에너지 | 기본 공격력 | 필요 경험치 |
|------|--------|-----------|-----------|-----------|
| 1 | 100 | 100 | 10 | 100 |
| 2 | 110 | 105 | 12 | 150 |
| 3 | 120 | 110 | 14 | 225 |
| 4 | 130 | 115 | 16 | 338 |
| 5 | 140 | 120 | 18 | 507 |

#### 적 스탯

| 적 유형 | HP | 공격력 | 방어력 | 이동속도 | 경험치 보상 |
|--------|-----|-------|-------|---------|-----------|
| 갱스터 (일반) | 60 | 8 | 3 | 3.5 m/s | 25 |
| 갱스터 (강화) | 80 | 12 | 5 | 4.0 m/s | 40 |
| 차원 변이체 | 120 | 18 | 8 | 3.0 m/s | 100 |

#### 데미지 공식

```
최종 데미지 = (기본 데미지 × (1 + (레벨-1) × 0.1)) - 방어력
최소 데미지 = 1

크리티컬 확률: 10%
크리티컬 배율: 1.5x
```

#### 스킬 에너지 소모

| 스킬 | 에너지 소모 | 쿨타임 |
|------|-----------|-------|
| 테슬라 충격기 | 20 | 8초 |
| 에테르 파동 | 15 | 6초 |
| 융합 콤보 (자동) | 0 | 15초 |

### 2.12 전투 UI

```
[전투 HUD 구성]

┌─────────────────────────────────────────────────────────────┐
│ [HP Bar]                                    [Enemy HP Bar]   │
│ ██████████████░░░░ 75/100                   Target: Gangster │
│                                             ████░░░░ 50/80   │
│                                                              │
│                                                              │
│                                                              │
│                                                              │
│                                                              │
│                                                              │
│                                                              │
│    [Q] 테슬라 ██████░░ CD: 3s                                 │
│    [R] 에테르 ████████░░ Ready                                │
│    [FUSION] ░░░░░░░░░░ 차원 전격 대기                         │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 대화 시스템

### 3.1 개요

NPC와의 분기 대화를 처리하는 시스템입니다.

```
[대화 시스템 구조]

DialogueData (ScriptableObject)
       │
       ▼
DialogueManager ──► DialogueUI
       │                │
       └────────────────┴──► 선택지 처리
                                  │
                                  ▼
                           퀘스트 시작 / 플래그 설정
```

### 3.2 대화 데이터 구조

```csharp
[CreateAssetMenu(fileName = "NewDialogue", menuName = "GoldenAge/Dialogue Data")]
public class DialogueData : ScriptableObject
{
    public string dialogueID;
    public string dialogueTitle;    // 에디터용
    public DialogueLine[] lines;

    [Header("조건")]
    public string requiredFlag;     // 이 플래그가 있어야 대화 가능
    public string requiredQuest;    // 이 퀘스트가 활성화되어 있어야 대화 가능
}

[System.Serializable]
public class DialogueLine
{
    public string speakerName;
    public Sprite speakerPortrait;

    [TextArea(3, 5)]
    public string text;

    public AudioClip voiceLine;     // 음성 (선택)

    [Header("선택지 (비어있으면 자동 진행)")]
    public DialogueChoice[] choices;
}

[System.Serializable]
public class DialogueChoice
{
    public string choiceText;
    public DialogueData nextDialogue;

    [Header("결과")]
    public string setFlag;          // 선택 시 설정할 플래그
    public string startQuest;       // 선택 시 시작할 퀘스트
    public int relationshipChange;  // 호감도 변화 (-10 ~ +10)
}
```

### 3.3 DialogueManager

```csharp
public class DialogueManager : Singleton<DialogueManager>
{
    [Header("UI 참조")]
    [SerializeField] private DialogueUI dialogueUI;

    private DialogueData currentDialogue;
    private int currentLineIndex;
    private bool isDialogueActive;

    // 플래그 저장소
    private HashSet<string> gameFlags = new();

    public event System.Action OnDialogueStarted;
    public event System.Action OnDialogueEnded;

    public void StartDialogue(DialogueData dialogue)
    {
        if (isDialogueActive) return;

        // 조건 체크
        if (!string.IsNullOrEmpty(dialogue.requiredFlag) &&
            !HasFlag(dialogue.requiredFlag))
        {
            Debug.Log("대화 조건 미충족: " + dialogue.requiredFlag);
            return;
        }

        isDialogueActive = true;
        currentDialogue = dialogue;
        currentLineIndex = 0;

        GameManager.Instance.ChangeState(GameState.Dialogue);
        dialogueUI.Show();
        OnDialogueStarted?.Invoke();

        DisplayCurrentLine();
    }

    private void DisplayCurrentLine()
    {
        if (currentLineIndex >= currentDialogue.lines.Length)
        {
            EndDialogue();
            return;
        }

        DialogueLine line = currentDialogue.lines[currentLineIndex];
        dialogueUI.DisplayLine(line);

        // 음성 재생
        if (line.voiceLine != null)
        {
            AudioManager.Instance.PlayVoice(line.voiceLine);
        }
    }

    public void NextLine()
    {
        DialogueLine currentLine = currentDialogue.lines[currentLineIndex];

        // 선택지가 있으면 선택 대기
        if (currentLine.choices != null && currentLine.choices.Length > 0)
        {
            dialogueUI.ShowChoices(currentLine.choices);
            return;
        }

        // 다음 라인으로
        currentLineIndex++;
        DisplayCurrentLine();
    }

    public void SelectChoice(int choiceIndex)
    {
        DialogueLine currentLine = currentDialogue.lines[currentLineIndex];
        DialogueChoice choice = currentLine.choices[choiceIndex];

        // 플래그 설정
        if (!string.IsNullOrEmpty(choice.setFlag))
        {
            SetFlag(choice.setFlag);
        }

        // 퀘스트 시작
        if (!string.IsNullOrEmpty(choice.startQuest))
        {
            QuestManager.Instance.StartQuest(choice.startQuest);
        }

        // 호감도 변화
        if (choice.relationshipChange != 0)
        {
            // NPC 호감도 시스템 연동
        }

        // 다음 대화로 전환 또는 종료
        if (choice.nextDialogue != null)
        {
            currentDialogue = choice.nextDialogue;
            currentLineIndex = 0;
            DisplayCurrentLine();
        }
        else
        {
            EndDialogue();
        }
    }

    public void EndDialogue()
    {
        isDialogueActive = false;
        currentDialogue = null;
        currentLineIndex = 0;

        dialogueUI.Hide();
        GameManager.Instance.ChangeState(GameState.Exploration);
        OnDialogueEnded?.Invoke();
    }

    // ===== 플래그 시스템 =====
    public void SetFlag(string flag)
    {
        gameFlags.Add(flag);
    }

    public bool HasFlag(string flag)
    {
        return gameFlags.Contains(flag);
    }

    public void RemoveFlag(string flag)
    {
        gameFlags.Remove(flag);
    }
}
```

### 3.4 대화 UI

```csharp
public class DialogueUI : MonoBehaviour
{
    [Header("UI 요소")]
    [SerializeField] private GameObject dialoguePanel;
    [SerializeField] private Image speakerPortrait;
    [SerializeField] private TMP_Text speakerNameText;
    [SerializeField] private TMP_Text dialogueText;
    [SerializeField] private GameObject continueIndicator;

    [Header("선택지")]
    [SerializeField] private GameObject choicePanel;
    [SerializeField] private ChoiceButton[] choiceButtons;

    [Header("타이핑 효과")]
    [SerializeField] private float typingSpeed = 0.03f;

    private Coroutine typingCoroutine;
    private bool isTyping;
    private string fullText;

    public void Show()
    {
        dialoguePanel.SetActive(true);
        choicePanel.SetActive(false);
    }

    public void Hide()
    {
        dialoguePanel.SetActive(false);
    }

    public void DisplayLine(DialogueLine line)
    {
        speakerNameText.text = line.speakerName;
        speakerPortrait.sprite = line.speakerPortrait;
        speakerPortrait.gameObject.SetActive(line.speakerPortrait != null);

        continueIndicator.SetActive(false);
        choicePanel.SetActive(false);

        // 타이핑 효과
        if (typingCoroutine != null)
            StopCoroutine(typingCoroutine);
        typingCoroutine = StartCoroutine(TypeText(line.text));
    }

    private IEnumerator TypeText(string text)
    {
        isTyping = true;
        fullText = text;
        dialogueText.text = "";

        foreach (char c in text)
        {
            dialogueText.text += c;
            yield return new WaitForSeconds(typingSpeed);
        }

        isTyping = false;
        continueIndicator.SetActive(true);
    }

    public void OnContinuePressed()
    {
        if (isTyping)
        {
            // 타이핑 스킵
            StopCoroutine(typingCoroutine);
            dialogueText.text = fullText;
            isTyping = false;
            continueIndicator.SetActive(true);
        }
        else
        {
            DialogueManager.Instance.NextLine();
        }
    }

    public void ShowChoices(DialogueChoice[] choices)
    {
        choicePanel.SetActive(true);
        continueIndicator.SetActive(false);

        for (int i = 0; i < choiceButtons.Length; i++)
        {
            if (i < choices.Length)
            {
                choiceButtons[i].gameObject.SetActive(true);
                choiceButtons[i].Setup(i, choices[i].choiceText);
            }
            else
            {
                choiceButtons[i].gameObject.SetActive(false);
            }
        }
    }
}
```

### 3.5 프로토타입 대화 예시

```
[NPC: 술집 주인 - 첫 대화]

DialogueID: "bartender_intro"

Line 1:
  Speaker: "마이크 (술집 주인)"
  Text: "처음 보는 얼굴이군. 여긴 아무나 오는 곳이 아닌데..."
  Choices: (없음)

Line 2:
  Speaker: "마이크"
  Text: "뭐, 손님은 손님이지. 뭘 마실 건가?"
  Choices:
    [1] "정보가 필요해요. 최근 이상한 일 없었나요?"
        → Next: "bartender_quest_start"
        → SetFlag: "asked_about_incidents"
    [2] "그냥 위스키 한 잔 주세요."
        → Next: "bartender_drink"
    [3] "아무것도요. 실례했습니다."
        → End Dialogue
```

---

## 4. 인벤토리 시스템

### 4.1 개요

프로토타입에서는 최소한의 인벤토리만 구현합니다.

```
[인벤토리 구조]

┌─────────────────────────────────────┐
│           인벤토리 (12칸)            │
├─────┬─────┬─────┬─────┬─────┬─────┤
│ [1] │ [2] │ [3] │ [4] │ [5] │ [6] │
├─────┼─────┼─────┼─────┼─────┼─────┤
│ [7] │ [8] │ [9] │[10] │[11] │[12] │
└─────┴─────┴─────┴─────┴─────┴─────┘

프로토타입 범위:
- 아이템 획득/버리기
- 소모품 사용
- 퀘스트 아이템 보관
```

### 4.2 인벤토리 클래스

```csharp
public class Inventory : MonoBehaviour
{
    [SerializeField] private int maxSlots = 12;

    private List<InventorySlot> slots = new();

    public event System.Action OnInventoryChanged;

    private void Awake()
    {
        // 슬롯 초기화
        for (int i = 0; i < maxSlots; i++)
        {
            slots.Add(new InventorySlot());
        }
    }

    public bool AddItem(ItemData item, int amount = 1)
    {
        // 이미 있는 아이템이면 스택
        if (item.maxStack > 1)
        {
            InventorySlot existingSlot = slots.Find(s =>
                s.item == item && s.amount < item.maxStack);

            if (existingSlot != null)
            {
                int addAmount = Mathf.Min(amount, item.maxStack - existingSlot.amount);
                existingSlot.amount += addAmount;
                amount -= addAmount;
                OnInventoryChanged?.Invoke();

                if (amount <= 0) return true;
            }
        }

        // 빈 슬롯 찾기
        InventorySlot emptySlot = slots.Find(s => s.item == null);
        if (emptySlot != null)
        {
            emptySlot.item = item;
            emptySlot.amount = Mathf.Min(amount, item.maxStack);
            OnInventoryChanged?.Invoke();
            return true;
        }

        // 인벤토리 가득 참
        Debug.Log("인벤토리가 가득 찼습니다!");
        return false;
    }

    public bool RemoveItem(ItemData item, int amount = 1)
    {
        InventorySlot slot = slots.Find(s => s.item == item);
        if (slot == null) return false;

        slot.amount -= amount;
        if (slot.amount <= 0)
        {
            slot.item = null;
            slot.amount = 0;
        }

        OnInventoryChanged?.Invoke();
        return true;
    }

    public bool HasItem(ItemData item, int amount = 1)
    {
        int total = slots.Where(s => s.item == item).Sum(s => s.amount);
        return total >= amount;
    }

    public void UseItem(int slotIndex)
    {
        if (slotIndex < 0 || slotIndex >= slots.Count) return;

        InventorySlot slot = slots[slotIndex];
        if (slot.item == null || !slot.item.isConsumable) return;

        // 아이템 효과 적용
        ApplyItemEffect(slot.item);

        // 수량 감소
        slot.amount--;
        if (slot.amount <= 0)
        {
            slot.item = null;
            slot.amount = 0;
        }

        OnInventoryChanged?.Invoke();
    }

    private void ApplyItemEffect(ItemData item)
    {
        PlayerStats stats = GetComponent<PlayerStats>();

        if (item.healAmount > 0)
        {
            stats.Heal(item.healAmount);
        }

        if (item.energyRestore > 0)
        {
            stats.RestoreEnergy(item.energyRestore);
        }
    }

    public List<InventorySlot> GetAllSlots() => slots;
}

[System.Serializable]
public class InventorySlot
{
    public ItemData item;
    public int amount;
}
```

### 4.3 인벤토리 UI

```csharp
public class InventoryUI : MonoBehaviour
{
    [SerializeField] private GameObject inventoryPanel;
    [SerializeField] private InventorySlotUI[] slotUIs;
    [SerializeField] private Inventory inventory;

    private void OnEnable()
    {
        inventory.OnInventoryChanged += RefreshUI;
    }

    private void OnDisable()
    {
        inventory.OnInventoryChanged -= RefreshUI;
    }

    public void Toggle()
    {
        inventoryPanel.SetActive(!inventoryPanel.activeSelf);
        if (inventoryPanel.activeSelf)
        {
            RefreshUI();
        }
    }

    private void RefreshUI()
    {
        var slots = inventory.GetAllSlots();
        for (int i = 0; i < slotUIs.Length; i++)
        {
            if (i < slots.Count)
            {
                slotUIs[i].Setup(slots[i]);
            }
        }
    }
}
```

---

## 5. 퀘스트 시스템

### 5.1 개요

프로토타입에서는 메인 퀘스트 1개만 추적합니다.

```
[프로토타입 메인 퀘스트: "기이한 사건"]

목표 1: 술집 주인과 대화하기
    │
    ▼
목표 2: 목격자 3명 찾아서 대화하기
    │
    ▼
목표 3: 수상한 창고 조사하기
    │
    ▼
목표 4: 갱스터 2명 처치하기
    │
    ▼
목표 5: 증거물 획득 후 돌아오기
```

### 5.2 퀘스트 데이터

```csharp
[CreateAssetMenu(fileName = "NewQuest", menuName = "GoldenAge/Quest Data")]
public class QuestData : ScriptableObject
{
    public string questID;
    public string questName;

    [TextArea(3, 5)]
    public string description;

    public QuestObjective[] objectives;

    [Header("보상")]
    public int expReward;
    public ItemData[] itemRewards;

    [Header("다음 퀘스트")]
    public QuestData nextQuest;
}

[System.Serializable]
public class QuestObjective
{
    public string objectiveID;

    [TextArea(2, 3)]
    public string description;

    public ObjectiveType type;
    public string targetID;         // 대상 ID
    public int requiredCount = 1;

    [Header("선택적")]
    public string locationHint;     // 위치 힌트
    public Vector3 markerPosition;  // 맵 마커 위치
}

public enum ObjectiveType
{
    TalkToNPC,      // NPC와 대화
    KillEnemy,      // 적 처치
    CollectItem,    // 아이템 수집
    ReachLocation,  // 위치 도달
    Investigate     // 오브젝트 조사
}
```

### 5.3 QuestManager

```csharp
public class QuestManager : Singleton<QuestManager>
{
    [Header("퀘스트 데이터")]
    [SerializeField] private QuestData[] allQuests;

    private Dictionary<string, QuestProgress> activeQuests = new();
    private HashSet<string> completedQuests = new();

    public event System.Action<QuestData> OnQuestStarted;
    public event System.Action<QuestData> OnQuestCompleted;
    public event System.Action<QuestObjective> OnObjectiveUpdated;

    public void StartQuest(string questID)
    {
        QuestData quest = System.Array.Find(allQuests, q => q.questID == questID);
        if (quest == null)
        {
            Debug.LogError($"퀘스트를 찾을 수 없음: {questID}");
            return;
        }

        if (activeQuests.ContainsKey(questID) || completedQuests.Contains(questID))
        {
            return; // 이미 진행 중이거나 완료됨
        }

        QuestProgress progress = new QuestProgress
        {
            quest = quest,
            currentObjectiveIndex = 0,
            objectiveProgress = new int[quest.objectives.Length]
        };

        activeQuests.Add(questID, progress);
        OnQuestStarted?.Invoke(quest);

        // UI 알림
        Debug.Log($"퀘스트 시작: {quest.questName}");
    }

    public void UpdateObjective(ObjectiveType type, string targetID, int amount = 1)
    {
        foreach (var kvp in activeQuests)
        {
            QuestProgress progress = kvp.Value;
            QuestData quest = progress.quest;

            if (progress.currentObjectiveIndex >= quest.objectives.Length)
                continue;

            QuestObjective currentObj = quest.objectives[progress.currentObjectiveIndex];

            // 현재 목표와 일치하는지 확인
            if (currentObj.type == type && currentObj.targetID == targetID)
            {
                progress.objectiveProgress[progress.currentObjectiveIndex] += amount;

                // 목표 달성 체크
                if (progress.objectiveProgress[progress.currentObjectiveIndex] >=
                    currentObj.requiredCount)
                {
                    progress.currentObjectiveIndex++;
                    OnObjectiveUpdated?.Invoke(currentObj);

                    // 모든 목표 완료 체크
                    if (progress.currentObjectiveIndex >= quest.objectives.Length)
                    {
                        CompleteQuest(kvp.Key);
                    }
                    else
                    {
                        // 다음 목표 알림
                        QuestObjective nextObj = quest.objectives[progress.currentObjectiveIndex];
                        Debug.Log($"다음 목표: {nextObj.description}");
                    }
                }
            }
        }
    }

    private void CompleteQuest(string questID)
    {
        if (!activeQuests.TryGetValue(questID, out QuestProgress progress))
            return;

        QuestData quest = progress.quest;

        // 보상 지급
        PlayerStats stats = FindObjectOfType<PlayerStats>();
        stats.AddExperience(quest.expReward);

        Inventory inventory = FindObjectOfType<Inventory>();
        foreach (var item in quest.itemRewards)
        {
            inventory.AddItem(item);
        }

        // 완료 처리
        activeQuests.Remove(questID);
        completedQuests.Add(questID);
        OnQuestCompleted?.Invoke(quest);

        Debug.Log($"퀘스트 완료: {quest.questName}");

        // 다음 퀘스트 자동 시작
        if (quest.nextQuest != null)
        {
            StartQuest(quest.nextQuest.questID);
        }
    }

    public QuestProgress GetActiveQuest(string questID)
    {
        activeQuests.TryGetValue(questID, out QuestProgress progress);
        return progress;
    }

    public QuestObjective GetCurrentObjective(string questID)
    {
        if (activeQuests.TryGetValue(questID, out QuestProgress progress))
        {
            if (progress.currentObjectiveIndex < progress.quest.objectives.Length)
            {
                return progress.quest.objectives[progress.currentObjectiveIndex];
            }
        }
        return null;
    }

    public bool IsQuestCompleted(string questID)
    {
        return completedQuests.Contains(questID);
    }
}

[System.Serializable]
public class QuestProgress
{
    public QuestData quest;
    public int currentObjectiveIndex;
    public int[] objectiveProgress;
}
```

### 5.4 퀘스트 UI

```csharp
public class QuestUI : MonoBehaviour
{
    [Header("UI 요소")]
    [SerializeField] private GameObject questPanel;
    [SerializeField] private TMP_Text questNameText;
    [SerializeField] private TMP_Text objectiveText;
    [SerializeField] private TMP_Text progressText;

    [Header("알림")]
    [SerializeField] private GameObject notificationPanel;
    [SerializeField] private TMP_Text notificationText;

    private string trackedQuestID;

    private void OnEnable()
    {
        QuestManager.Instance.OnQuestStarted += OnQuestStarted;
        QuestManager.Instance.OnQuestCompleted += OnQuestCompleted;
        QuestManager.Instance.OnObjectiveUpdated += OnObjectiveUpdated;
    }

    public void TrackQuest(string questID)
    {
        trackedQuestID = questID;
        RefreshUI();
    }

    private void RefreshUI()
    {
        QuestProgress progress = QuestManager.Instance.GetActiveQuest(trackedQuestID);
        if (progress == null)
        {
            questPanel.SetActive(false);
            return;
        }

        questPanel.SetActive(true);
        questNameText.text = progress.quest.questName;

        QuestObjective obj = progress.quest.objectives[progress.currentObjectiveIndex];
        objectiveText.text = obj.description;

        int current = progress.objectiveProgress[progress.currentObjectiveIndex];
        progressText.text = $"{current}/{obj.requiredCount}";
    }

    private void OnQuestStarted(QuestData quest)
    {
        ShowNotification($"새 퀘스트: {quest.questName}");
        TrackQuest(quest.questID);
    }

    private void OnQuestCompleted(QuestData quest)
    {
        ShowNotification($"퀘스트 완료: {quest.questName}");
    }

    private void OnObjectiveUpdated(QuestObjective obj)
    {
        ShowNotification("목표 완료!");
        RefreshUI();
    }

    private void ShowNotification(string message)
    {
        notificationText.text = message;
        notificationPanel.SetActive(true);
        Invoke(nameof(HideNotification), 3f);
    }

    private void HideNotification()
    {
        notificationPanel.SetActive(false);
    }
}
```

---

## 6. 저장/불러오기 시스템

### 6.1 개요

JSON 직렬화를 사용한 간단한 세이브 시스템입니다.

```
[저장 데이터 구조]

SaveData
├── 플레이어 정보 (위치, HP, 레벨)
├── 인벤토리 상태
├── 퀘스트 진행 상황
├── 게임 플래그
└── 저장 시간
```

### 6.2 세이브 데이터 구조

```csharp
[System.Serializable]
public class SaveData
{
    // 메타 정보
    public string saveName;
    public string saveTime;
    public float playTime;

    // 플레이어
    public PlayerSaveData player;

    // 인벤토리
    public List<InventorySlotSaveData> inventory;

    // 퀘스트
    public List<QuestSaveData> activeQuests;
    public List<string> completedQuests;

    // 게임 플래그
    public List<string> gameFlags;
}

[System.Serializable]
public class PlayerSaveData
{
    public float posX, posY, posZ;
    public float rotY;
    public int currentHealth;
    public int maxHealth;
    public int level;
    public int experience;
}

[System.Serializable]
public class InventorySlotSaveData
{
    public string itemID;
    public int amount;
}

[System.Serializable]
public class QuestSaveData
{
    public string questID;
    public int currentObjectiveIndex;
    public int[] objectiveProgress;
}
```

### 6.3 SaveManager

```csharp
public class SaveManager : Singleton<SaveManager>
{
    private const string SAVE_FOLDER = "/Saves/";
    private const string SAVE_EXTENSION = ".json";

    private string SavePath => Application.persistentDataPath + SAVE_FOLDER;

    protected override void Awake()
    {
        base.Awake();

        // 저장 폴더 생성
        if (!Directory.Exists(SavePath))
        {
            Directory.CreateDirectory(SavePath);
        }
    }

    public void SaveGame(string slotName)
    {
        SaveData data = new SaveData
        {
            saveName = slotName,
            saveTime = System.DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"),
            playTime = Time.timeSinceLevelLoad
        };

        // 플레이어 데이터 수집
        data.player = CollectPlayerData();

        // 인벤토리 데이터 수집
        data.inventory = CollectInventoryData();

        // 퀘스트 데이터 수집
        data.activeQuests = CollectQuestData();
        data.completedQuests = QuestManager.Instance.GetCompletedQuestIDs();

        // 게임 플래그 수집
        data.gameFlags = DialogueManager.Instance.GetAllFlags();

        // JSON 직렬화 및 저장
        string json = JsonUtility.ToJson(data, true);
        string filePath = SavePath + slotName + SAVE_EXTENSION;
        File.WriteAllText(filePath, json);

        Debug.Log($"게임 저장 완료: {filePath}");
    }

    public void LoadGame(string slotName)
    {
        string filePath = SavePath + slotName + SAVE_EXTENSION;

        if (!File.Exists(filePath))
        {
            Debug.LogError($"세이브 파일 없음: {filePath}");
            return;
        }

        string json = File.ReadAllText(filePath);
        SaveData data = JsonUtility.FromJson<SaveData>(json);

        // 플레이어 복원
        ApplyPlayerData(data.player);

        // 인벤토리 복원
        ApplyInventoryData(data.inventory);

        // 퀘스트 복원
        ApplyQuestData(data.activeQuests, data.completedQuests);

        // 게임 플래그 복원
        DialogueManager.Instance.SetAllFlags(data.gameFlags);

        Debug.Log($"게임 로드 완료: {slotName}");
    }

    private PlayerSaveData CollectPlayerData()
    {
        GameObject player = GameObject.FindGameObjectWithTag("Player");
        PlayerStats stats = player.GetComponent<PlayerStats>();

        return new PlayerSaveData
        {
            posX = player.transform.position.x,
            posY = player.transform.position.y,
            posZ = player.transform.position.z,
            rotY = player.transform.eulerAngles.y,
            currentHealth = stats.CurrentHealth,
            maxHealth = stats.MaxHealth,
            level = stats.Level,
            experience = stats.Experience
        };
    }

    private void ApplyPlayerData(PlayerSaveData data)
    {
        GameObject player = GameObject.FindGameObjectWithTag("Player");
        CharacterController cc = player.GetComponent<CharacterController>();

        // CharacterController는 직접 위치 변경이 안 되므로 비활성화 후 이동
        cc.enabled = false;
        player.transform.position = new Vector3(data.posX, data.posY, data.posZ);
        player.transform.rotation = Quaternion.Euler(0, data.rotY, 0);
        cc.enabled = true;

        PlayerStats stats = player.GetComponent<PlayerStats>();
        stats.SetHealth(data.currentHealth, data.maxHealth);
        stats.SetLevel(data.level, data.experience);
    }

    private List<InventorySlotSaveData> CollectInventoryData()
    {
        Inventory inventory = FindObjectOfType<Inventory>();
        List<InventorySlotSaveData> data = new();

        foreach (var slot in inventory.GetAllSlots())
        {
            if (slot.item != null)
            {
                data.Add(new InventorySlotSaveData
                {
                    itemID = slot.item.name, // ScriptableObject 이름
                    amount = slot.amount
                });
            }
        }

        return data;
    }

    private void ApplyInventoryData(List<InventorySlotSaveData> data)
    {
        Inventory inventory = FindObjectOfType<Inventory>();
        inventory.Clear();

        foreach (var slotData in data)
        {
            ItemData item = Resources.Load<ItemData>($"Items/{slotData.itemID}");
            if (item != null)
            {
                inventory.AddItem(item, slotData.amount);
            }
        }
    }

    private List<QuestSaveData> CollectQuestData()
    {
        // QuestManager에서 구현
        return QuestManager.Instance.GetActiveQuestsSaveData();
    }

    private void ApplyQuestData(List<QuestSaveData> active, List<string> completed)
    {
        // QuestManager에서 구현
        QuestManager.Instance.LoadQuestData(active, completed);
    }

    public string[] GetSaveSlots()
    {
        if (!Directory.Exists(SavePath))
            return new string[0];

        string[] files = Directory.GetFiles(SavePath, "*" + SAVE_EXTENSION);
        for (int i = 0; i < files.Length; i++)
        {
            files[i] = Path.GetFileNameWithoutExtension(files[i]);
        }
        return files;
    }

    public void DeleteSave(string slotName)
    {
        string filePath = SavePath + slotName + SAVE_EXTENSION;
        if (File.Exists(filePath))
        {
            File.Delete(filePath);
        }
    }
}
```

### 6.4 저장/불러오기 UI

```
[저장/불러오기 메뉴]

┌─────────────────────────────────────────────────────┐
│                    저장 슬롯                          │
├─────────────────────────────────────────────────────┤
│ [슬롯 1] 자동 저장 - 2026-01-28 14:30              │
│          플레이 시간: 00:45:23                       │
│                                                     │
│ [슬롯 2] 수동 저장 - 2026-01-28 13:15              │
│          플레이 시간: 00:30:10                       │
│                                                     │
│ [슬롯 3] 비어 있음                                   │
│                                                     │
├─────────────────────────────────────────────────────┤
│         [저장]    [불러오기]    [삭제]               │
└─────────────────────────────────────────────────────┘
```

---

## 7. 시스템 간 의존성

```
[시스템 의존성 다이어그램]

                    GameManager
                        │
         ┌──────────────┼──────────────┐
         │              │              │
         ▼              ▼              ▼
   InputManager    AudioManager   SaveManager
         │
         ▼
  ┌──────────────┐
  │PlayerMovement│◄────────────────────┐
  └──────┬───────┘                     │
         │                             │
         ▼                             │
  ┌──────────────┐    ┌────────────┐   │
  │InteractionSys│───►│DialogueMgr │   │
  └──────────────┘    └─────┬──────┘   │
                            │          │
                            ▼          │
                    ┌──────────────┐   │
                    │ QuestManager │───┤
                    └──────┬───────┘   │
                           │           │
         ┌─────────────────┼───────────┘
         │                 │
         ▼                 ▼
  ┌──────────────┐  ┌──────────────┐
  │ PlayerCombat │  │  Inventory   │
  └──────┬───────┘  └──────────────┘
         │
         ▼
  ┌──────────────┐
  │ CombatManager│
  └──────────────┘
```

---

## 8. 구현 우선순위

### Phase 1 (1~2주차): 기본 프레임워크
1. GameManager 싱글톤
2. InputManager (New Input System)
3. PlayerMovement (이동/회전)
4. 기본 카메라 설정

### Phase 2 (3~4주차): 전투 시스템
1. PlayerCombat (기본 공격)
2. EnemyAI (기본 행동)
3. 데미지 시스템
4. 스킬 시스템 (테슬라, 에테르)

### Phase 3 (5~6주차): 전투 고도화
1. 융합 콤보 시스템
2. 상태이상 시스템
3. 전투 UI
4. 전투 밸런싱

### Phase 4 (7~8주차): 대화/퀘스트
1. DialogueManager
2. 대화 UI
3. QuestManager
4. 퀘스트 UI

### Phase 5 (9~10주차): 인벤토리/저장
1. Inventory 시스템
2. 인벤토리 UI
3. SaveManager
4. 저장/불러오기 UI

### Phase 6 (11~12주차): 통합/폴리싱
1. 시스템 통합 테스트
2. 버그 수정
3. UI 폴리싱
4. 최종 빌드

---

*본 문서는 GoldenAge 프로토타입의 시스템 명세서입니다.*
*다음 문서: 레벨 디자인 문서*
